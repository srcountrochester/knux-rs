# Knux (Knex for Rust)

*Быстрый и удобный конструктор SQL-запросов для Rust с интерфейсом, вдохновлённым Knex.js.*

[![crates.io](https://img.shields.io/crates/v/knux-rs.svg)](https://crates.io/crates/knux-rs)
[![docs.rs](https://docs.rs/knux-rs/badge.svg)](https://docs.rs/knux-rs)

[![CI](https://github.com/srcountrochester/knux-rs/actions/workflows/ci.yml/badge.svg?branch=master)](https://github.com/srcountrochester/knux-rs/actions/workflows/ci.yml)
![coverage](https://img.shields.io/badge/dynamic/json?url=https://srcountrochester.github.io/knux-rs/badges/coverage.json&query=$.coverage&suffix=%25&label=coverage)

[![OpenSSF Scorecard](https://api.scorecard.dev/projects/github.com/srcountrochester/knux-rs/badge)](https://scorecard.dev/viewer/?uri=github.com/srcountrochester/knux-rs)
[![cargo-deny](https://github.com/srcountrochester/knux-rs/actions/workflows/deny.yml/badge.svg?branch=master)](https://github.com/srcountrochester/knux-rs/actions/workflows/deny.yml)

![license](https://img.shields.io/badge/dynamic/toml?url=https://raw.githubusercontent.com/srcountrochester/knux-rs/master/Cargo.toml&query=$.package.license&label=license)
![edition](https://img.shields.io/badge/dynamic/toml?url=https://raw.githubusercontent.com/srcountrochester/knux-rs/master/Cargo.toml&query=%24.package.edition&label=edition)

[![LOC](https://tokei.rs/b1/github/srcountrochester/knux-rs?category=code&style=flat)](https://tokei.rs/b1/github/srcountrochester/knux-rs)
![code size](https://img.shields.io/github/languages/code-size/srcountrochester/knux-rs)



## Введение

**Knux** – это библиотека для программного построения SQL-запросов в Rust, обеспечивающая удобный fluent-интерфейс, похожий на популярный JavaScript-пакет Knex. Цель проекта – упростить написание сложных SQL-выражений, сохраняя полный контроль над результирующим запросом и высокую производительность (без накладных расходов ORM). Knux **не является ORM** – он не управляет состоянием объектов и не привязан к моделям. Вы непосредственно конструируете текст SQL-запроса, а получение и обработка результатов остаются за вами (например, средствами **SQLx**). Такой подход даёт гибкость: вы пишете запросы, близкие к чистому SQL, но пользуетесь безопасным API для предотвращения SQL-инъекций и удобного комбинирования условий.

Knux поддерживает несколько SQL-диалектов. На данный момент доступны SQLite, PostgreSQL и MySQL. По умолчанию включена поддержка SQLite (через feature-флаг `sqlite`), однако при добавлении зависимости вы можете явно указать нужную СУБД. Библиотека работает в асинхронной среде (используется `tokio` и `sqlx`), поэтому запросы выполняются неблокирующим образом с помощью `async/await`.

## Основные возможности

- Удобный цепочечный API (fluent-интерфейс) для построения SQL-запросов SELECT, вдохновлённый Knex.js.
- Отсутствие ORM-слоя: Knux не управляет состоянием объектов и не привязан к моделям – он напрямую генерирует SQL-запросы, предоставляя полный контроль над итоговым запросом и избегая накладных расходов ORM.
- Встроенный DSL для выражений и условий, обеспечивающий типобезопасную привязку значений и защиту от SQL-инъекций.
- Поддержка всех CRUD операций через SELECT/INSERT/UPDATE/DELETE конструкции.
- Поддержка сложных SQL-конструкций: различные виды JOIN и вложенные подзапросы, объединения результатов запросов (UNION/INTERSECT/EXCEPT), а также другие сложные конструкции SQL.
- Поддержка нескольких SQL-диалектов (SQLite, PostgreSQL, MySQL) с выбором через feature-флаги (только один диалект за сборку).
- Асинхронное выполнение запросов благодаря интеграции с **SQLx** (runtime **Tokio**): результат можно получить напрямую, просто вызвав `.await` на построенном запросе.
- Возможность получить сгенерированный SQL-запрос и список параметров (через метод `.to_sql()`) без выполнения – удобно для отладки и логирования.
- Дополнительные методы для типовых условий: `where_null`, `where_between`, `where_like` и другие.
- Поддержка транзакций и возможность безопасного исполнения в разных тредах (thread safety).

## Установка

Добавьте Knux в зависимости вашего проекта **Cargo.toml**. По умолчанию используется SQLite, поэтому минимальная конфигурация такая:

```toml
[dependencies]
knux = "0.1.0"
```

Если вы планируете использовать PostgreSQL или MySQL, укажите соответствующие feature-флаги и отключите дефолтный (SQLite). Например, для PostgreSQL:

```toml
[dependencies]
knux = { version = "0.1.0", default-features = false, features = ["postgres"] }
```

Аналогично для MySQL: `features = ["mysql"]`. **Важно:** активируйте только **один** диалект за раз. Если включить одновременно несколько (например, `["postgres", "sqlite"]`), сборка завершится с ошибкой. Убедитесь также, что в проекте настроен асинхронный рантайм **Tokio**, так как выполнение запросов происходит асинхронно. 

*(Примечание: Knux также предоставляет опциональные фичи для поддержки дополнительных типов данных – например, `time`/`chrono` (даты и время), `uuid`, `serde_json` (JSON), `rust_decimal` – о них подробнее в разделе **Диалекты и плейсхолдеры**.)*

## Быстрый старт

1. **Подключение к базе данных.** Сначала создаётся конфигурация соединения и исполнитель запросов. В конфигурации указываем строку подключения и другие параметры (например, размер пула соединений):

   ```rust
   use knux::executor::{ExecutorConfig, QueryExecutor};

   // Настраиваем конфигурацию подключения (SQLite в памяти, 1 соединение)
   let cfg = ExecutorConfig::builder()
       .database_url("sqlite::memory:")
       .max_connections(1)
       .build();
   // Устанавливаем соединение и получаем исполнитель запросов
   let db = QueryExecutor::connect(cfg).await.unwrap();
   ```

2. **Построение SQL-запроса.** Используя `db`, создаём новый построитель запроса (`QueryBuilder`) и цепочкой методов задаём необходимые части SQL. В этом примере выберем все поля из таблицы `users` и присоединим к ней подзапрос из таблицы `accounts`:

   ```rust
   use knux::expression::helpers::{col, val};

   // Формируем запрос: выбираем * из public.users
   let users_query = db
       .query()                      // начинаем новый запрос
       .schema("public")             // указываем схему (например, для Postgres)
       .from("users")                // основная таблица "users"
       .select("*")                  // выбрать все столбцы
       // Присоединяем подзапрос: SELECT * FROM accounts WHERE user_id = 1
       .join(
           |qb| qb.from("accounts").select("*").r#where(col("user_id").eq(val(1))),
           "users.id = accounts.user_id"
       );
   ```
   Обратите внимание: метод `.join()` принимает замыкание, в котором строится подзапрос (`qb` – новый `QueryBuilder` для подзапроса), и условие соединения. В данном случае мы соединяем пользователей с аккаунтами по условию `users.id = accounts.user_id`, при этом подзапрос ограничен условием `user_id = 1`. Для вызова метода `.where` внутри замыкания используется синтаксис `r#where` (так как `where` является ключевым словом в Rust).

   Можно использовать и упрощённый вариант:
   ```rust
   use knux::expression::helpers::{col, val};

   // Формируем запрос: выбираем * из public.users
   let users_query = db
       .query()                      // начинаем новый запрос
       .schema("public")             // указываем схему (например, для Postgres)
       .from("users")                // основная таблица "users"
       .select("*")                  // выбрать все столбцы
       .join("accounts", "users.id = accounts.user_id");
   ```

3. **Выполнение запроса или получение SQL-строки.** После того как запрос построен, его можно либо выполнить в базе данных (получив результаты), либо сгенерировать SQL для отладки/логирования:

   - **Выполнение запроса:** просто ожидаем результат `users_query` как `Future`:
     ```rust
     let users: Vec<User> = users_query.await.unwrap();
     ```
     Когда вы вызываете `.await` на объекте запроса, Knux автоматически генерирует SQL и выполняет его через пул соединений **SQLx**. Переменная `users` будет содержать полученные результаты (например, вектор структур `User` или строк `sqlx::Row`, в зависимости от того, как вы типизируете результат и настроили SQLx). Примечание: SQLx позволяет напрямую маппить результаты на структуры, если тип `User` соответствует колонкам запроса.

   - **Получение SQL без выполнения:** если нужно посмотреть, какой запрос сформирован, используйте метод `.to_sql()`:
     ```rust
     let (sql, params) = users_query.to_sql().unwrap();
     ```
     Метод `.to_sql()` возвращает сгенерированный SQL-запрос в виде строки и список параметров. В нашем примере переменная `sql` будет примерно такой:
     ```sql
     SELECT * 
     FROM public.users 
     JOIN (SELECT * FROM accounts WHERE user_id = ?) AS _t1 
     ON users.id = accounts.user_id;
     ```
     А `params` будет содержать связанные значения для параметров (здесь для плейсхолдера `?` это `[1]`). Этот способ удобен для отладки – можно проверить итоговый SQL без обращения к базе данных.

4. **Вставка данных**. По аналогии с SELECT используем цепочные методы для построения и выполнения запроса:
    ```rust
    use knux::expression::helpers::{col, val};
    use sqlx::FromRow;

    #[derive(FromRow)]
    struct User { id: i64, name: String, age: i32, is_active: bool }

    // Одна строка с возвратом вставленной записи
    let inserted: Vec<User> = db
        .query()
        .into("users")
        .insert((
            col("name"),      val("Alice"),
            col("age"),       val(30),
            col("is_active"), val(true),
        ))
        .returning("*")
        .await
        .unwrap();

    // Несколько строк через columns(...) + плоские values
    let many: Vec<User> = db
        .query()
        .into("users")
        .columns((col("name"), col("age"), col("is_active")))
        .insert((
            val("Bob"),  val(18), val(false),
            val("Cara"), val(25), val(true),
        ))
        .returning("*")
        .await
        .unwrap();

    ```

5. **Обновление данных**.
    ```rust
    use knux::expression::helpers::{col, val};
    use sqlx::FromRow;

    #[derive(FromRow)]
    struct User { id: i64, name: String, age: i32, is_active: bool }

    let updated: Vec<User> = db
        .query()
        .update("users")
        .set((col("age"), val(26)))
        .r#where(col("is_active").eq(val(true)))
        .returning("*")
        .await
        .unwrap();

    ```

6. **Удаление записей**.
    ```rust
    use knux::expression::helpers::{col, table, val};
    use sqlx::FromRow;

    #[derive(FromRow)]
    struct User { id: i64, name: String, age: i32, is_active: bool }

    let deleted: Vec<User> = db
        .query()
        .delete(table("users"))
        .r#where(col("name").eq(val("Bob")))
        .returning("*")
        .await
        .unwrap();

    ```

7. **Работа с транзакциями**.
    ```rust
    use knux::expression::helpers::{col, val};
    use sqlx::FromRow;

    #[derive(FromRow)]
    struct User { id: i64, name: String, age: i32, is_active: bool }

    let mut tx = db.begin().await.unwrap();

    let inserted: Vec<User> = tx
        .query()
        .into("users")
        .insert((
            col("name"),      val("Zoe"),
            col("age"),       val(27),
            col("is_active"), val(true),
        ))
        .returning("*")
        .await
        .unwrap();

    // … при необходимости — другие операции в той же транзакции …

    tx.commit().await.unwrap(); // либо tx.rollback().await.unwrap();

    ```
    *Примечания:*
      - Для `INSERT`/`UPDATE`/`DELETE` без `RETURNING` используйте `exec()` и проверяйте `rows_affected`.
      - Во всех примерах используются хелперы `col(...)`, `val(...)` и `table(...)`, но можно использовать и с троки и в большинстве случаев замыкания и подзапросы.

## Архитектура

Под капотом Knux строит **абстрактное синтаксическое дерево (AST)** запроса, а затем преобразует его в итоговый SQL. Такой дизайн разделяет этапы конструирования и рендеринга запроса:

- **QueryBuilder (построитель)** – основной интерфейс для составления запросов. Он хранит внутреннее представление SELECT-запроса: список выбираемых колонок, источники (`FROM` и `JOIN`), условия, группировки, сортировки и т.д. При каждом вызове метода (`from`, `where`, `group_by` и пр.) QueryBuilder обновляет своё AST-представление. Встроенные оптимизации используют `SmallVec` для хранения небольших списков (например, до нескольких колонок) на стеке, уменьшая количество выделений в куче и повышая производительность при типовых запросах. Многие методы построителя способны принимать аргументы разных типов – например, название таблицы как `&str`, или замыкание, возвращающее подзапрос. Это реализовано через трейты `IntoQBArg` и `ArgList`, которые позволяют неявно преобразовать строку, срез, вектор, подзапрос `QueryBuilder` или замыкание в унифицированный вид (внутренний тип `QBArg`). Благодаря этому API гибкое: можно передавать как отдельные значения, так и списки/массивы значений, и даже вложенные запросы, а библиотека позаботится о правильной обёртке этих аргументов.

- **Expression (выражение)** – тип, представляющий отдельное выражение SQL (булево условие, вычисление, агрегат и т.д.). Expression содержит в себе узел `sqlparser::ast::Expr` и аккумулятор параметров `Param`, связанных с этим выражением. Например, вызов `val(42)` создаёт Expression, который в AST является параметром (`?` или `$1`), а само значение 42 сохраняется внутри `Expression.params`. Различные методы Expression (сравнения, логические операции, агрегаты и т.п.) комбинируют AST-узлы и объединяют списки параметров. Таким образом, каждый Expression "знает" о своих параметрах, и они будут переданы в итоговый запрос отдельно, защищая от SQL-инъекций.

- **Renderer (генератор SQL)** – модуль, отвечающий за преобразование построенного AST в строку SQL, учитывая синтаксис целевого диалекта. Когда запрос готов и требуется получить SQL (например, при вызове `.to_sql()` или выполнении), QueryBuilder сначала собирает финальное AST-представление запроса, а Renderer превращает его в строку. Renderer подставляет плейсхолдеры для параметров в нужном формате (например, заменяет условные `?` на `$1`, `$2`, ... для PostgreSQL), корректно экранирует идентификаторы (кавычки или обратные апострофы в зависимости от СУБД), и формирует полный корректный SQL-текст. Одновременно возвращается и список параметров `Param` – порядок и количество параметров точно соответствует сгенерированным плейсхолдерам в SQL.

- **Executor (исполнитель)** – abstraкция над пулом соединений SQLx. `QueryExecutor` содержит внутри `DbPool` соответствующего типа (Sqlite, Pg или MySql) и предоставляет метод `.query()` для создания нового QueryBuilder, "привязанного" к этому пулу. Когда вы вызываете `.await` на QueryBuilder, он через Renderer получает SQL и параметры, а затем вызывает `sqlx` для выполнения этого SQL с заданными параметрами. Executor скрывает детали конкретной СУБД: вы пишете один и тот же код построения запроса независимо от диалекта, и просто выбираете нужный feature-флаг при сборке.

Ниже приведена обобщённая схема модулей Knux:

| Компонент          | Роль и ответственность                                 |
|--------------------|--------------------------------------------------------|
| **QueryBuilder**   | Построение AST SQL-запроса (SELECT) через fluent-API. Хранит части запроса (колонки, таблицы, JOIN, условия, группировки, сортировки, лимиты и пр.), накапливает параметры. Предоставляет методы для поэтапного добавления этих частей. |
| **Expression**     | Представление отдельного SQL-выражения или условия. Позволяет конструировать вложенные выражения безопасно (например, `col("age").gt(val(18)).and(col("active").eq(val(true)))`). Гарантирует, что все литеральные значения попадут в параметры, а не напрямую в SQL. |
| **Renderer**       | Генерация итогового SQL-строки из AST с учётом диалекта. Реализует политику плейсхолдеров (вопросительные знаки vs. нумерованные), экранирование имен схем/таблиц/колонок, синтаксис объединений, подзапросов и т.д. Возвращает пару «SQL + параметры». Также может проводить базовую валидацию AST (например, что все части на месте). |
| **Executor**       | Управление подключением к базе данных (через `sqlx`). Предоставляет пул соединений, на котором основывается QueryBuilder. Отвечает за выполнение готового SQL: принимает строку запроса и параметры от Renderer и вызывает соответствующие методы `sqlx` для выполнения. Результаты возвращаются в виде `Future`, что интегрируется с `async/await`. |

# Основные методы построителя запросов

Knux предоставляет богатый набор методов цепочного вызова для поэтапного конструирования SQL-запроса. Ниже перечислены основные методы `QueryBuilder` (все они возвращают модифицированный `QueryBuilder`, позволяя объединять вызовы последовательно):

- `query().from(source)` – задать исходный источник данных для запроса (`FROM ...`). Принимает название таблицы (`&str`) или замыкание, возвращающее подзапрос `QueryBuilder` (если нужно подставить подзапрос в секции FROM). Можно вызывать несколько раз для перечисления нескольких источников через запятую (например, при объединении без условия или для CROSS JOIN). Если перед вызовом `.from()` был указан `.schema()`, то к имени таблицы автоматически добавится префикс схемы.

- `schema(name)` – указать схему по умолчанию для таблицы(ц). Обычно используется для PostgreSQL или MySQL, где имя схемы/БД предшествует имени таблицы. Если вызвать `.schema("public").from("users")`, сгенерируется фрагмент `FROM public.users`. Указанная схема также применяется ко всем последующим таблицам в текущем построителе, пока не будет изменена или очищена.

- `select(columns)` – указать, какие столбцы или выражения выбирать (`SELECT ...`). Принимает либо строковое имя столбца (например, `"name"`), специальную строку `"*"` (для выбора всех столбцов), либо коллекцию имен (кортеж, массив, срез) и даже выражения (`Expression`). Например, `.select(("id", "name"))` выберет два столбца, `.select(vec!["id", "name"])` – то же самое, а `.select(col("id").count().alias("count"))` – добавит агрегатное выражение `COUNT(id) AS count`. Можно вызывать `.select` несколько раз: при повторном вызове новые элементы будут добавлены к уже выбираемым (если нужно, например, динамически сформировать список полей). Если ни разу не вызвать `.select`, по умолчанию будет выбран `SELECT *`.

- `join(target, on)` – выполнить объединение (JOIN) с другой таблицей или подзапросом. Первый аргумент – либо имя таблицы (`&str`), либо замыкание, возвращающее подзапрос `QueryBuilder`. Второй аргумент – условие соединения (`ON ...`) в виде строки или `Expression`. По умолчанию `.join()` выполняет INNER JOIN. Также доступны методы для других типов объединений: `.left_join()`, `.right_join()`, `.full_join()`, а также варианты для NATURAL JOIN (если нужно, например, `.natural_left_join()`). Вы можете вызывать методы JOIN многократно для добавления нескольких соединений. Для каждого JOIN, если цель – подзапрос, ему автоматически присваивается псевдоним (например, `_t1`, `_t2` и т.д.), который можно использовать в условии.

- `where(condition)` – добавить условие фильтрации (`WHERE ...`). Принимает объект `Expression`, который удобно получить с помощью DSL выражений (см. раздел **Выражения** ниже). Если вызвать `.where()` несколько раз, все условия будут объединены через AND. Для использования OR или более сложных группировок – объедините нужные подусловия заранее на уровне Expression (например, с помощью `.and()` / `.or()` между `Expression`). Имеются также специальные методы-вариации: см. раздел **Расширение выражений** о таких методах, как `.where_null()`, `.where_between()`, `.where_like()` и др., упрощающих написание типовых условий.

- `group_by(columns)` – задать список полей для группировки (`GROUP BY ...`). Принимает одно или несколько имен столбцов или выражений. Можно передать строку, `Expression`, либо список/кортеж (например, `.group_by(("country", "city"))`). При многократном вызове `.group_by` дополнительные поля будут добавлены к уже заданным. Группировка обычно применяется вместе с агрегатными функциями.

- `having(condition)` – задать условие для сгруппированных данных (`HAVING ...`). По семантике аналогичен `.where()`, но применяется после группировки. Принимает `Expression` – как правило, условие над агрегатными выражениями. Например: `.having(col("count").gt(val(10)))` ограничит результаты группировки теми группами, где счетчик больше 10. Если вызвать несколько раз, условия объединятся через AND (по аналогии с `.where`).

- `order_by(ordering)` – задать сортировку результатов (`ORDER BY ...`). Принимает имя столбца (`&str`), `Expression` или их список/кортеж для сортировки. По умолчанию сортировка по возрастанию (ASC). Чтобы задать убывающий порядок, можно указать направление в строке, например: `.order_by("created_at DESC")`. Если нужно отсортировать по нескольким столбцам, можно передать массив/кортеж: например, `.order_by(("country", "city"))` задаст `ORDER BY country, city`. Многократный вызов `.order_by` добавляет дополнительные уровни сортировки (вторичная, третичная сортировка и т.д.).

- `limit(n)` / `offset(n)` – ограничить количество возвращаемых строк (`LIMIT` и `OFFSET`). Принимают числовое значение (целое `u64`). Метод `.limit(10)` оставит не более 10 строк в результате, а `.offset(5)` пропустит первые 5 строк. Можно задавать только лимит, только смещение или оба сразу. Если вызвать `.limit` или `.offset` повторно, новое значение заменит предыдущее (берётся последнее указанное).

- `distinct(columns?)` – указать, что в запросе должны быть только уникальные записи (`SELECT DISTINCT`). При вызове без аргументов (`.distinct()`) это эквивалентно `SELECT DISTINCT ...` по всем выбранным столбцам. В PostgreSQL Knux поддерживает синтаксис `DISTINCT ON (cols)`: вы можете передать список столбцов, например `.distinct(("country", "city"))`, чтобы выбрать уникальные комбинации этих полей (для других СУБД этот аргумент будет игнорирован). Вызывать `.distinct()` следует до указания столбцов через `.select()`, чтобы он применился к результатам.

- `union(query)` – объединить два запроса через `UNION`. Принимает второй запрос как `QueryBuilder` или замыкание. Результат – текущий QueryBuilder, представляющий объединение исходного и нового запроса. Также доступны методы `.union_all()`, `.intersect()`, `.intersect_all()`, `.except()` и `.except_all()` для соответствующих множеств SQL (поддержка зависит от СУБД: например, `INTERSECT` и `EXCEPT` доступны в Postgres и SQLite). Вы можете объединять несколько запросов, вызывая эти методы цепочкой. Обратите внимание, что объединяемые запросы должны иметь совместимый набор столбцов.

- `with(name, subquery)` – добавить Common Table Expression (CTE, выражение `WITH`). Принимает имя CTE и подзапрос (`QueryBuilder` или замыкание, формирующее подзапрос). После вызова `.with("temp", qb_sub)` можно использовать CTE `temp` в основном запросе как обычную таблицу в `.from()` или `.join()`. Можно вызывать `.with()` несколько раз для определения нескольких CTE. Порядок вызовов определит порядок перечисления CTE в итоговом SQL (в начале запроса). 

- `alias(name)` – задать псевдоним для текущего запроса (если он будет использоваться как подзапрос в другом запросе). Например, вызов:  
  ```rust
  let sub = db.query().from("users").alias("u");
  ```  
  сформирует подзапрос `(... FROM users) AS u`, который можно затем передать в `.from()` или `.join()` другого QueryBuilder. Псевдоним полезен при составлении вложенных запросов или самосоединений. Для отдельных выражений аналогично доступен метод `.alias()` (см. DSL выражений) – он задаёт имя результирующему столбцу или выражению.

- `to_sql()` – сгенерировать SQL-строку и список параметров, соответствующие текущему построенному запросу, **без** выполнения его в базе данных. Возвращает `Result<(String, Vec<Param>)>`, где `Param` – перечисление, инкапсулирующее значения параметров (числа, строки, даты и т.д.). Обычно этот метод используется для отладки или логирования. При успешном вызове `.to_sql()` внутренний QueryBuilder **не** уничтожается и его можно дальше модифицировать или выполнить (каждый вызов `.to_sql` заново генерирует SQL). Если при построении запроса были допущены логические ошибки (например, отсутствует источник данных для SELECT), `.to_sql()` вернёт ошибку с объяснением.

## Выражения (DSL для условий и полей)

Модуль expression библиотеки Knux предоставляет удобный Domain-Specific Language для конструирования отдельных выражений: логических условий, вычислений, агрегатов и т.д. Эти выражения используются при построении запросов (например, передаются в методы `.where()`, `.having()`, или используются внутри `.select()` и в условиях `.join()`).

**Основные возможности DSL выражений:**

- **Колонки и значения:** функция `col("table.column")` создаёт выражение-столбец. Можно указывать имя с префиксом таблицы через точку (`"users.id"`) или только название колонки (`"id"`) – при генерации SQL Knux автоматически поставит нужный префикс, если задан `.schema()` или если столбец используется с alias-ом таблицы. Функция `val(value)` создаёт параметризованное выражение-литерал для безопасной подстановки значения. Например, `col("age")` и `val(18)` задают колонку и значение. Все значения, обёрнутые через `val`, будут переданы в запрос параметрами (как `?` или `$1`, `$2`, ...), что надёжно защищает от SQL-инъекций. Если же требуется вставить в запрос литерал вручную (например, имя функции или специальный SQL-литерал), можно использовать `lit("RAW_SQL")` – он создаст выражение без параметризации. Делайте это осторожно и только для доверенных выражений, поскольку `lit` просто вставляет строку в SQL как есть.

- **Сравнения:** методами выражения можно задавать типичные SQL-сравнения: `.eq` (равно), `.ne` (не равно), `.gt` (больше), `.lt` (меньше), `.gte/.lte` (больше либо равно / меньше либо равно). Каждый из них возвращает новое выражение типа `Expression`, которое можно дальше комбинировать или передавать в запрос. Например, выражение `col("age").gt(val(18))` соответствует условию `age > 18`.

   Помимо этого, для проверки на `NULL` используются методы `.is_null()` и `.is_not_null()`. Например, `col("deleted_at").is_null()` создаст выражение `deleted_at IS NULL`. Эти методы упрощают работу с nullable-полями (аналогично ручному сравнению с NULL, но в виде безопасного `Expression`).

- **Логические операции:** для объединения нескольких условий используются методы `.and()` и `.or()`. Они принимают другое выражение `Expression` и возвращают новое комбинированное выражение. Например:
   
   ```rust
   // age > 18 AND active = true
   let condition = col("age").gt(val(18))
       .and(col("active").eq(val(true)));
   ```
   
   Полученное выражение `condition` можно передать в `.where(condition)` запроса. Аналогично, метод `.or()` объединит два выражения через OR. Вы можете выстраивать цепочку логических комбинаций, вызывая `.and/.or` каскадно для сложных условий. Для отрицания условия предоставлен метод `.not()`, который возвращает выражение, эквивалентное `NOT (expr)`. Например, `col("flag").eq(val(false)).not()` даст `NOT(flag = false)`.

- **Списки и множества:** для проверки вхождения значения в набор используются методы `.in_list()` и `.not_in_list()`. Они позволяют сформировать выражение `IN (...)` или `NOT IN (...)`. Например:
   
   ```rust
   // country IN ('US', 'UK')
   let countries = vec![val("US"), val("UK")];
   let expr = col("country").in_list(countries);
   ```
   
   Это выражение соответствует условию `country IN (?, ?)`, а параметрами к запросу будут `["US", "UK"]`. Метод `.not_in_list` аналогично задаёт отрицание этого условия. Внутрь `.in_list(...)` можно передать любой тип, реализующий трейты коллекции аргументов (например, `&[Expression]`, `Vec<Expression>`, `Vec<&str>` и т.д.) – все элементы будут корректно собраны в SQL-список.

- **Агрегатные функции:** для любого числового или текстового выражения доступны методы агрегирования: `.count()`, `.sum()`, `.avg()`, `.min()`, `.max()`. Эти методы возвращают новое выражение `Expression`, представляющее соответствующую SQL-функцию. Пример: `col("id").count()` превращается в выражение `COUNT(id)`. Такие агрегаты обычно используются в `.select()` (вместе с `.group_by`, если нужно), и им часто задают псевдоним для удобства. Например:
   
   ```rust
   // SELECT COUNT(id) AS user_count FROM users
   let count_expr = col("id").count().alias("user_count");
   let result: (i64,) = db.query().from("users").select(count_expr).await.unwrap();
   ```
   
   В примере выше сформируется запрос, который подсчитает количество пользователей.
   
   Если требуется посчитать уникальные значения, поддерживается конструкция `DISTINCT` для агрегатов: вызов метода `.distinct()` перед агрегатной функцией применит `DISTINCT` к её аргументу. Например, выражение `col("country").distinct().count()` соответствует `COUNT(DISTINCT country)` – оно подсчитает количество уникальных стран.

- **Арифметические операции:** DSL поддерживает базовые математические операции над выражениями. Доступны методы `.add()`, `.sub()`, `.mul()`, `.div()`, которые генерируют соответствующие операторы `+`, `-`, `*`, `/` в SQL. Например, `col("price").mul(val(0.8))` представляет выражение `price * 0.8`. Кроме того, есть метод `.neg()`, возвращающий унарный минус (например, `col("balance").neg()` соответствует `-balance`). Вы можете сочетать несколько таких операций; они будут правильно сгруппированы в AST в соответствии с порядком вызовов.

- **Произвольные выражения:** на случай, если в DSL ещё нет нужной функции или оператора, предусмотрена функция-хелпер `raw()`. Она позволяет встроить в AST произвольное выражение, сформированное вручную. `raw` принимает замыкание `FnOnce() -> sqlparser::ast::Expr` – внутри него вы можете сконструировать необходимый узел AST, используя типы из пакета `sqlparser`. Обычно в приложениях это редко требуется, но такой способ даёт максимальную гибкость для очень специфичных случаев (например, использование операторов JSON `->>` или вызов нестандартной функции СУБД). В более простых ситуациях старайтесь применять существующие методы DSL или безопасно комбинировать `lit` и `val`.

Все объекты типа `Expression` безопасно комбинируются друг с другом: методы возвращают новые `Expression`, а сами исходные остаются неизменны (подобно `String` или `Iterator` API в Rust). Параметры, заключённые через `val()`, аккумулируются и переносятся в итоговый запрос автоматически. Это означает, что вы можете строить сложные условия, не беспокоясь о подстановке значений – Knux сам пронумерует и подставит placeholders, а значения передаст отдельно.

## Расширение выражений и специальные условия

Помимо базового DSL, библиотека Knux предоставляет ряд удобных методов для упрощения распространённых случаев и работы с нестандартными конструкциями:

- **Проверка на NULL**
вместо явного сравнения с `NULL` (которое отличается от обычного `=`) можно использовать вспомогательные методы `where_null` и `where_not_null`. Например:

    ```rust
    // WHERE deleted_at IS NULL
    qb.where_null("deleted_at");
    ```

    Этот вызов эквивалентен `.where(col("deleted_at").is_null())`. Метод принимает имя столбца (`&str`) или `Expression` и сам сформирует выражение `IS NULL`. Аналогично, `.where_not_null("deleted_at")` даёт условие `deleted_at IS NOT NULL`. Для HAVING доступны методы `.having_null()` / `.having_not_null()` (работают так же, но после группировки).

- **Диапазоны (BETWEEN)**
для удобства есть методы `.where_between(field, low, high)` и `.where_not_between(field, low, high)`, упрощающие создание условий на диапазон. Они принимают имя или выражение поля и две границы диапазона (значения или `Expression`s). Например:

    ```rust
    // WHERE score BETWEEN 10 AND 20
    qb.where_between("score", 10, 20);
    ```

    Сформирует условие `score BETWEEN ? AND ?` с параметрами `[10, 20]`. Метод `.where_not_between` генерирует `NOT BETWEEN`. Соответствующие методы `.having_between` / `.having_not_between` существуют для условий HAVING.

- **Поиск по шаблону**
для условий LIKE/ILIKE предусмотрен метод `.where_like(field, pattern)` (и `.where_ilike` для PostgreSQL, если нужен регистронезависимый поиск). Первый аргумент – имя столбца или `Expression`, второй – строка‑шаблон или `Expression`. В строке шаблона используйте символы `%` и `_` как в SQL. Пример:

    ```rust
    // WHERE name LIKE 'A%'
    qb.where_like("name", "A%");
    ```

    Будет соответствовать всем именам, начинающимся с `"A"`. Обратите внимание, что шаблон `'A%'` здесь передаётся как литерал – в итоговом SQL он станет параметром (`?` или `$1`) со значением `A%`. Таким образом, само содержание шаблона защищено от SQL‑инъекции так же, как и другие параметры. Для отрицания условия (NOT LIKE) вы можете воспользоваться методом `.where_raw` (см. ниже) либо построить выражение вручную: например `.where(col("name").not().like(val("A%")))` – однако проще может быть сразу использовать `.where_raw("name NOT LIKE ?", val("A%"))`.

- **Произвольные условия (RAW)**
в случаях, когда DSL не покрывает какой‑то синтаксис условия, на выручку приходит метод `.where_raw(sql_fragment, params...)`. Он позволяет вписать произвольное условие в секцию WHERE. Например:

    ```rust
    qb.where_raw("JSON_EXTRACT(data, '$.user') = ?", val("admin"));
    ```

    Этот вызов вставит в SQL условие `JSON_EXTRACT(data, '$.user') = ?` и привяжет значение `"admin"` к параметрам. Метод `.where_raw` принимает строку с фрагментом SQL, который может содержать плейсхолдеры `?` (или `$N` – согласно диалекту), а также один или несколько параметров типа `Expression` или значений, обёрнутых через `val`. Каждый такой параметр будет последовательно подставлен на место `?`. Пользуйтесь `.where_raw` осторожно: ответственность за корректность передаваемого SQL лежит на разработчике. Всегда старайтесь передавать внешние значения через параметры (`?`) и `val()`, а не конкатенировать их в строку запроса.

    Аналогичные методы существуют для других частей запроса: `.having_raw(...)` для условий HAVING, `.join_raw(...)` для нестандартных JOIN (если, к примеру, нужно вписать специфичную секцию `ON`, которую нельзя легко выразить через DSL), и `.from_raw(...)` для сложных случаев в секции FROM. Обычно они не требуются, но могут быть полезны для быстрого обходного пути. Во всех случаях старайтесь комбинировать их с `val()` для передачи динамических значений.

Все перечисленные выше методы расширения имеют суффиксы, соответствующие секции запроса: `where_...` и `having_...` – для условий, `join_raw` – для соединений, и т.д. Эти методы делают API более удобным, позволяя избежать ручного использования `raw()` в большинстве распространённых ситуаций. Благодаря им синтаксис запроса остаётся выразительным и лаконичным, даже когда требуется нечто, выходящее за рамки базового DSL.

## Диалекты и плейсхолдеры

Knux изначально разрабатывался как аналог Knex.js, способный работать с разными СУБД. В текущей версии поддерживаются три диалекта: **SQLite**, **PostgreSQL** и **MySQL**. Выбор диалекта происходит на этапе компиляции через feature‑флаги (см. раздел *Установка*). В зависимости от выбранного диалекта генерация SQL имеет некоторые отличия:

- **Плейсхолдеры для параметров.** В сгенерированном SQL Knux автоматически подставляет правильные плейсхолдеры. Для SQLite и MySQL используются ненумерованные плейсхолдеры ``?``. Для PostgreSQL — нумерованные плейсхолдеры ``$1``, ``$2``, ``$3`` и т.д. Например, условие `.where(col("id").eq(val(5)))` превратится в `id = ?` для SQLite/MySQL и в `id = $1` для PostgreSQL. Нумерация параметров происходит в порядке их добавления в запрос. Вам, как пользователю библиотеки, не нужно об этом беспокоиться — достаточно вызывать `val(value)`, а Knux сам проставит корректные placeholder‑ы и сформирует массив значений в нужном порядке. Если вы вызываете `.to_sql()`, то во втором элементе кортежа получите вектор `Vec<Param>` — он уже правильно упорядочен для подстановки в полученный SQL.

- **Специфика синтаксиса.** Renderer учитывает диалектальные различия. Например, имена таблиц и столбцов в PostgreSQL заключаются в двойные кавычки `"users"` при необходимости (если имя содержит заглавные буквы или зарезервировано), а в MySQL по умолчанию экранирование происходит обратными апострофами `` `users` `` (в стиле Knex). SQLite принимает оба стиля кавычек, и Knux по умолчанию использует двойные кавычки. Также PostgreSQL поддерживает конструкции `SELECT DISTINCT ON (...)` и кастомные функции, MySQL — свои функции и ограничения. Knux старается генерировать максимально переносимый SQL, приближённый к стандарту SQL92/99. Там, где поведение разнится (например, отсутствие `LIMIT ... OFFSET` в SQL Server, которого тут нет, или нумерация параметров), это вынесено в уровень Renderer и прозрачно для пользователя.

- **Работа с типами и SQLx.** Выбор feature‑флага влияет на тип пула соединений SQLx, с которым работает `QueryExecutor`, а также на допустимые типы параметров. При включённом `sqlite` `QueryExecutor` оперирует `SqlitePool`, при `postgres` — `PgPool`, при `mysql` — `MySqlPool`. Однако API Knux унифицировано: методы построителя запросов и `Expression` не меняются. Просто под капотом разные диалекты направляют запросы в разные драйверы SQLx. Фактически, Knux компилируется с зависимостью `sqlx` только под выбранную СУБД (поэтому не растёт размер бинарника за счёт неиспользуемых драйверов).

- **Optional‑типы параметров.** Как упоминалось, Knux поддерживает расширяемый набор типов данных для параметров. Базовые типы (числа, строки, булевы) поддерживаются «из коробки». Если вы хотите использовать, например, `chrono::NaiveDateTime` или `uuid::Uuid` в качестве значения в `val()`, необходимо включить соответствующий feature. Фичи `time` и `chrono` добавляют поддержку типов времени/даты (через `Param::Time` / `Param::Chrono` variants и активацию нужных функций SQLx), `serde_json` — поддержку JSON (`serde_json::Value` будет передан как JSONB для Postgres или как текст для SQLite/MySQL), `uuid` — GUID/UUID, а `rust_decimal` — десятичные числа высокой точности. Включение этих фич расширяет вариант `Param` и позволяет напрямую использовать соответствующие типы в `.val()`. Без включения фичи вы всё равно можете передавать такие значения, но вам придётся конвертировать их вручную (например, дату в строку или число) перед вызовом `val`. Поэтому, если ваше приложение оперирует такими типами, рекомендуется активировать нужные фичи Knux, чтобы пользоваться ими нативно.

В итоге, **один и тот же код построения запроса** в Knux можно скомпилировать под разные диалекты. Отличаться будет только финальный синтаксис SQL‑строки и формат плейсхолдеров. Поведение же с точки зрения логики запроса останется одинаковым. Вы можете выбрать диалект, указав feature при сборке, или даже собрать несколько версий вашего приложения под разные СУБД. Сейчас Knux не поддерживает динамическое переключение диалектов во время выполнения (runtime) — выбор происходит на этапе компиляции для оптимальной интеграции с SQLx.

## Внесение вклада

Contributions приветствуются. Если вы нашли ошибку или у вас есть предложение по улучшению, пожалуйста, откройте соответствующий issue или отправьте pull request в репозиторий проекта. Будьте уверены, что описали проблему или предложение как можно подробнее – обсуждение новых возможностей и архитектурных изменений только приветствуется. Перед большим вкладом (значительные изменения или новые фичи) желательно сперва обсудить его через issue, чтобы убедиться в соответствии идеям проекта. Ваш вклад, будь то код, тесты, документация или просто обсуждение – ценен для развития Knux.

## Лицензия

Проект распространяется под лицензией MIT. Это означает, что вы свободны использовать Knux в своих приложениях, модифицировать исходный код и распространять свой форк или изменения – при условии сохранения уведомления об авторских правах и лицензии MIT в вашем продукте. Knux – открытое ПО, и мы рассчитываем, что оно будет полезно сообществу без лишних ограничений.