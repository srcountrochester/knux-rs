# Krust (Knex for Rust)

*Быстрый и удобный конструктор SQL-запросов для Rust с интерфейсом, вдохновлённым Knex.js.*

## Введение

**Krust** – это библиотека для построения SQL-запросов в Rust, обеспечивающая удобный fluent-интерфейс, похожий на популярный JavaScript-пакет Knex. Цель проекта – упростить написание сложных SQL-выражений, сохраняя контроль над запросами и производительность (без накладных расходов ORM). Krust **не является ORM**, то есть он не управляет состоянием объектов и не привязан к моделям – вы непосредственно конструируете SQL-запросы, а полученные результаты обрабатываете самостоятельно (например, с помощью **SQLx**). Такой подход даёт гибкость: вы пишете запросы, близкие к чистому SQL, но пользуетесь безопасным API для предотвращения SQL-инъекций и удобного комбинирования условий.

Krust поддерживает несколько SQL-диалектов. На данный момент доступны SQLite, PostgreSQL и MySQL – по умолчанию включена поддержка SQLite (через feature-флаг `sqlite`), но вы можете подключить и другие СУБД, указав соответствующие feature-флаги при добавлении зависимости. Библиотека работает в асинхронной среде (используется `tokio` и `sqlx`), поэтому вы сможете выполнять запросы неблокирующим образом с помощью `async/await`.

## Установка

Добавьте Krust в зависимости вашего проекта **Cargo.toml**. Например, чтобы подключить Krust с поддержкой SQLite (включена по умолчанию):

```toml
[dependencies]
krust = "0.1.0"
```

Если вы планируете использовать PostgreSQL или MySQL, укажите нужные фичи. Например, для PostgreSQL:

```toml
[dependencies]
krust = { version = "0.1.0", default-features = false, features = ["postgres"] }
```
Аналогично для MySQL: используйте `features = ["mysql"]`. Вы можете включить сразу несколько диалектов при необходимости. Убедитесь, что в проекте настроен асинхронный рантайм **Tokio**, так как выполнение запросов происходит асинхронно.

## Пример использования
Рассмотрим шаги построения и выполнения простого запроса с помощью Krust:

1. **Подключение к базе данных.** Сначала создаётся конфигурация и исполнитель запросов. В конфигурации указываем строку подключения и другие параметры (например, размер пула соединений):

    ```rust
    use krust::executor::{ExecutorConfig, QueryExecutor};

    // Настраиваем конфигурацию подключения (SQLite в памяти, 1 соединение)
    let cfg = ExecutorConfig::builder()
        .database_url("sqlite::memory:")
        .max_connections(1)
        .build();
    // Устанавливаем соединение и получаем исполнитель запросов
    let db = QueryExecutor::connect(cfg).await.unwrap();
    ```

2. **Построение SQL-запроса.** С помощью исполнителя `db` создаём новый построитель запроса и цепочкой методов задаём необходимые части SQL. В этом примере мы выберем все поля из таблицы `users` и присоединим к ней подзапрос из таблицы `accounts`:

    ```rust
    use krust::expression::helpers::{col, val};

    // Начинаем формировать запрос: выбираем * из public.users
    let users_query = db
        .query()                      // начинаем новый запрос
        .schema("public")             // указываем схему (например, для Postgres)
        .from("users")                // основная таблица users
        .select("*")                  // выбрать все столбцы
        // Присоединяем подзапрос: SELECT * FROM accounts WHERE user_id = 1
        .join(
            |qb| qb.from("accounts").select("*").r#where(col("user_id").eq(val(1))),
            "users.id = accounts.user_id"
        );
    ```
    Обратите внимание: метод `.join()` принимает замыкание, в котором строится подзапрос (`qb` – новый `QueryBuilder` для подзапроса), и условие соединения. В данном случае мы соединяем пользователей с аккаунтами, где `accounts.user_id = users.id`, при этом подзапрос ограничен условием `user_id = 1`. Методу `.r#where `используется префикс `r#` потому, что `where` является ключевым словом в Rust.

3. **Выполнение запроса или получение SQL-строки.** После того как запрос построен, его можно выполнить в базе данных (получив результаты) или сгенерировать SQL для отладки/логирования:
    - **Выполнение запроса:**
    ```rust
    let users: Vec<User> = users_query.await.unwrap();
    ```
    Когда вы ожидаете (`.await`) объект запроса, Krust выполняет построенный SQL через пул соединений **SQLx**. Переменная `users` будет содержать результат выполнения (например, набор строк из таблицы `users` с присоединёнными данными). Примечание: Тип результата зависит от контекста – вы можете получить сырые строки (`sqlx::Row`) или использовать возможности SQLx для маппинга на структуры.

    - **Получение SQL без выполнения:**
    ```rust
    let (sql, params) = users_query.to_sql();
    ```
    Метод `.to_sql()` возвращает сгенерированный SQL-запрос в виде строки и список параметров. В нашем примере `sql` может быть примерно таким:
    ```sql
    SELECT * FROM public.users 
    JOIN (SELECT * FROM accounts WHERE user_id = ?) AS _t1 
    ON users.id = accounts.user_id;
    ```
    А `params` будет содержать привязанные значения (здесь для плейсхолдера `?` будет `[1]`). Этот способ удобен для отладки – вы можете посмотреть, какой SQL сформировался, не выполняя его.

## Основные методы построителя запросов
Krust предоставляет набор методов для поэтапного конструирования SQL-запроса. Все они можно вызывать цепочкой (`builder.method1(...).method2(...).method3(...)`), формируя запрос шаг за шагом:

- `query().from(table)` – выбрать исходную таблицу (или подзапрос) для SELECT. Принимает название таблицы (`&str`) либо замыкание, возвращающее подзапрос `QueryBuilder` (если нужно подзапрос в секции FROM). Можно вызывать несколько раз для перечисления нескольких источников (будут перечислены через запятую).

- `schema(name)` – указать схему по умолчанию для таблицы. Если этот метод вызван перед `.from()`, то указанная схема будет префиксом к имени таблицы. Например, `.schema("public").from("users")` сформирует `FROM public.users`.

- `select(columns)` – указать, какие столбцы или выражения выбирать. Можно передать строковое имя столбца, `"*"` для всех столбцов, список кортежем/массивом, а также выражения (`Expression`). Например: `.select(("id", "name"))` выберет два столбца, а `.select(col("id").count().alias("count"))` – агрегатное выражение. Если вы не вызываете `select`, по умолчанию будет выбран `SELECT *`.

- `join(target, on)` – выполнить объединение (JOIN) с другой таблицей или подзапросом. Первый аргумент – либо имя таблицы (`&str`), либо замыкание с подзапросом (как в примере выше). Второй аргумент – условие соединения (ON) в виде строки или выражения. По умолчанию используется INNER JOIN. (На данный момент поддерживается только внутреннее соединение; другие типы (LEFT, RIGHT и пр.) могут появиться в будущем.) Вы можете вызывать `.join()` несколько раз для множественных JOIN.

- `where(condition)` – задать условие фильтра (WHERE). Принимает объект `Expression`, который можно сконструировать с помощью DSL выражений (см. раздел **“Выражения”** ниже). Если вы вызываете `.where()` несколько раз, условия будут объединены через AND (аналогично поведению Knex). Для объединения с OR или более сложных логических группировок – формируйте соответствующее выражение заранее (например, используя `.and/.or` на уровне `Expression`).

- `alias(name)` – задать псевдоним для текущего запроса, если он будет использоваться как подзапрос. Например: `db.query().from("users").alias("u")` сформирует FROM users AS u. Обычно это нужно при вложенных запросах или самосоединениях. (Для выражений alias работает аналогично – позволяет задать имя столбца в результате).

- `to_sql()` – сгенерировать SQL-строку и параметры, соответствующие текущему построенному запросу, без его выполнения.

Кроме указанных, Krust планирует поддержку и других методов (например, LIMIT, ORDER BY, GROUP BY и пр.). В текущей версии (0.1.0) основной упор сделан на генерацию SELECT-запросов.

## Выражения (DSL для условий и полей)
Библиотека Krust включает модуль `expression`, предоставляющий удобный DSL для конструирования отдельных выражений (условий, вычислений, агрегатов и пр.). Эти выражения используются в методах запроса (например, передаются в `.where()` или формируются внутри `.select()` и `.join()`). Ниже перечислены основные возможности DSL выражений:
- **Колонки и значения:** Функция `col("table.column")` создаёт выражение-столбец (можно указать с префиксом таблицы через точку или просто имя столбца). Функция `val(value)` создаёт параметр для безопасной подстановки значения. Например, `col("age")` и `val(18)`. Все значения, обёрнутые через `val`, передаются в запрос параметризованно (подставляются как `?` или `$1` и т.д. в SQL), что защищает от SQL-инъекций. Если нужно прямо вставить литерал (например, строку) в запрос, можно использовать `lit("TEXT")`, но делать это следует осторожно (в большинстве случаев лучше `val`).

- **Сравнения:** Методами выражения можно задавать сравнения: `.eq`, `.ne` (не равно), `.gt` (больше), `.lt` (меньше), `.gte/.lte` (больше либо равно / меньше либо равно). Каждый из них возвращает новое выражение типа `Expression`, которое можно дальше комбинировать. Пример: `col("age").gt(val(18))` создаст условие `age > 18`.

- **Логические операции:** Есть методы для объединения условий: `.and()` и `.or()`. Они принимают другое выражение и возвращают комбинированное выражение. Например:
    ```rust
    // age > 18 AND active = true
    let condition = col("age").gt(val(18))
        .and(col("active").eq(val(true)));
    ```
    Полученное выражение condition можно передать в `.where(condition)` построителя запроса. Аналогично, `.or` объединяет выражения через OR. Вы также можете комбинировать несколько условий, вызывая эти методы каскадно.

- **Списки и множества:** Для проверки вхождения значения в набор используются методы `.in_list()` и `.not_in_list()`. Они позволяют сформировать выражение IN (...) или NOT IN (...). Например:
    ```rust
    // country IN ('US','UK')
    let countries = vec![val("US"), val("UK")];
    let expr = col("country").in_list(countries);
    ```
    Это выражение будет соответствовать условию `country IN (?, ?)`, с параметрами `["US", "UK"]`. Соответственно, `.not_in_list` задаёт отрицание этого условия.

- **Агрегатные функции:** Вы можете легко создать агрегатные выражения. Для любого выражения типа Expression доступны методы агрегатов: `.count()`, `.sum()`, `.avg()`, `.min()`, `.max()`. Они возвращают новое выражение, представляющее соответствующую SQL-функцию. Например, `col("id").count()` – это выражение `COUNT(id)`. Такие выражения можно использовать в `.select()`, часто вместе с `.alias()`, чтобы задать имя результирующего столбца:
    ```rust
    // SELECT COUNT(id) AS user_count FROM users
    let count_expr = col("id").count().alias("user_count");
    let result = db.query().from("users").select(count_expr).await?;
    ```
    Также поддерживается конструкция `DISTINCT` для агрегатов: если вызвать `.distinct()` перед агрегатом, будет подсчитано уникальное значение. Пример: `col("country").distinct().count()` сформирует `COUNT(DISTINCT country)`.

- **Арифметические и другие операции:** DSL выражений включает базовые математические операции: `.add()`, `.sub()`, `.mul()`, `.div()` – для сложения, вычитания, умножения и деления выражений соответственно (они генерируют `+`, `-`, `*`, `/` в SQL). Кроме того, доступны методы `.neg()` (унарный минус) и некоторые другие вспомогательные функции. Для любых специфических случаев можно использовать функцию `raw()`, которая позволяет вручную встроить произвольное выражение в AST (абстрактное синтаксическое дерево) SQL. `raw` принимает замыкание, возвращающее `sqlparser::ast::Expr` – это на случай, если в DSL пока нет нужной функции. В простых случаях удобнее использовать `lit` или комбинацию существующих методов.

Все выражения типа `Expression` безопасно комбинируются с параметрами: библиотека автоматически собирает все значения, переданные через `val()`, и формирует финальный запрос с заполнителями и соответствующим списком параметров. В результате вы получаете безопасный и понятный SQL без ручной конкатенации строк.

## Заключение и планы развития
Krust (версия 0.1.0) – молодая библиотека, находящаяся в стадии активной разработки. Она уже позволяет строить сложные SELECT-запросы, облегчая работу с SQL в Rust-проектах. В дальнейших версиях планируется расширить функциональность: поддержка других типов запросов (INSERT/UPDATE/DELETE), методов для LIMIT/OFFSET, управление ORDER BY/GROUP BY, различные типы JOIN (LEFT, RIGHT, CROSS) и прочие возможности, свойственные полнофункциональным построителем запросов SQL.

Мы будем рады любому отклику и предложениям от сообщества! Вы можете оставлять отзывы, сообщать об ошибках и вносить свой вклад в развитие проекта.

## Внесение вклада
Contributions приветствуются. Если вы нашли баг или у вас есть предложение по улучшению, пожалуйста, откройте issue или отправьте pull request в репозиторий. Обсуждение новых возможностей и улучшений архитектуры проекта всегда приветствуется. Вместе мы сможем сделать Krust лучше! 🚀

## Лицензия
Проект распространяется на условиях свободной открытой лицензии. Вы свободны использовать Krust в своих приложениях. (*Конкретная лицензия будет указана в репозитории; планируется использование разрешительной лицензии, например MIT.*)